package bktree

import (
	"bytes"
	"fmt"
)

func (tree *Tree) AddNode(node *Node) (int, error) {
	nodeData := make([]byte, nodeByteSize)
	writer := bytes.NewBuffer(nodeData)

	err := node.SerializeToBinaryStream(writer)
	if err != nil {
		return -1, err
	}

	index := len(tree.Nodes) / nodeByteSize
	tree.Nodes = append(tree.Nodes, nodeData...)

	return index, nil
}

func (tree *Tree) AddEdge(edge *Edge) (int, error) {
	nodeData := make([]byte, nodeByteSize)
	writer := bytes.NewBuffer(nodeData)

	err := edge.SerializeToBinaryStream(writer)
	if err != nil {
		return -1, err
	}

	index := len(tree.Nodes) / nodeByteSize
	tree.Nodes = append(tree.Nodes, nodeData...)

	return index, nil
}

func (tree *Tree) GetNodeAtIndex(index int) (*Node, error) {
	offset := index * nodeByteSize // Use cached nodeSize
	if offset >= len(tree.Nodes) {
		return nil, fmt.Errorf("index out of bounds")
	}

	nodeData := tree.Nodes[offset : offset+nodeByteSize]

	nodeReader := bytes.NewReader(nodeData)

	node, err := DeserializeNodeFromBinaryStream(nodeReader)
	if err != nil {
		return nil, err
	}

	return node, err
}

func (tree *Tree) GetEdgeAtIndex(index int) (*Edge, error) {
	offset := index * edgeByteSize
	if offset >= len(tree.Edges) {
		return nil, fmt.Errorf("index out of bounds")
	}

	edgeData := tree.Edges[offset : offset+edgeByteSize]

	reader := bytes.NewReader(edgeData)

	edge, err := DeserializeEdgeFromBinaryStream(reader)
	if err != nil {
		return nil, err
	}

	return edge, err
}
