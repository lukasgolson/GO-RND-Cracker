// Code generated by capnpc-go. DO NOT EDIT.

package bk_tree

import (
	capnp "capnproto.org/go/capnp/v3"
	text "capnproto.org/go/capnp/v3/encoding/text"
	schemas "capnproto.org/go/capnp/v3/schemas"
)

type Node capnp.Struct

// Node_TypeID is the unique identifier for the type Node.
const Node_TypeID = 0xfc6199848da8bc43

func NewNode(s *capnp.Segment) (Node, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 2})
	return Node(st), err
}

func NewRootNode(s *capnp.Segment) (Node, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 2})
	return Node(st), err
}

func ReadRootNode(msg *capnp.Message) (Node, error) {
	root, err := msg.Root()
	return Node(root.Struct()), err
}

func (s Node) String() string {
	str, _ := text.Marshal(0xfc6199848da8bc43, capnp.Struct(s))
	return str
}

func (s Node) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Node) DecodeFromPtr(p capnp.Ptr) Node {
	return Node(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Node) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Node) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Node) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Node) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Node) Sequence() (capnp.Int8List, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return capnp.Int8List(p.List()), err
}

func (s Node) HasSequence() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s Node) SetSequence(v capnp.Int8List) error {
	return capnp.Struct(s).SetPtr(0, v.ToPtr())
}

// NewSequence sets the sequence field to a newly
// allocated capnp.Int8List, preferring placement in s's segment.
func (s Node) NewSequence(n int32) (capnp.Int8List, error) {
	l, err := capnp.NewInt8List(capnp.Struct(s).Segment(), n)
	if err != nil {
		return capnp.Int8List{}, err
	}
	err = capnp.Struct(s).SetPtr(0, l.ToPtr())
	return l, err
}
func (s Node) Seed() int32 {
	return int32(capnp.Struct(s).Uint32(0))
}

func (s Node) SetSeed(v int32) {
	capnp.Struct(s).SetUint32(0, uint32(v))
}

func (s Node) Children() (Edge_List, error) {
	p, err := capnp.Struct(s).Ptr(1)
	return Edge_List(p.List()), err
}

func (s Node) HasChildren() bool {
	return capnp.Struct(s).HasPtr(1)
}

func (s Node) SetChildren(v Edge_List) error {
	return capnp.Struct(s).SetPtr(1, v.ToPtr())
}

// NewChildren sets the children field to a newly
// allocated Edge_List, preferring placement in s's segment.
func (s Node) NewChildren(n int32) (Edge_List, error) {
	l, err := NewEdge_List(capnp.Struct(s).Segment(), n)
	if err != nil {
		return Edge_List{}, err
	}
	err = capnp.Struct(s).SetPtr(1, l.ToPtr())
	return l, err
}

// Node_List is a list of Node.
type Node_List = capnp.StructList[Node]

// NewNode creates a new list of Node.
func NewNode_List(s *capnp.Segment, sz int32) (Node_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 8, PointerCount: 2}, sz)
	return capnp.StructList[Node](l), err
}

// Node_Future is a wrapper for a Node promised by a client call.
type Node_Future struct{ *capnp.Future }

func (f Node_Future) Struct() (Node, error) {
	p, err := f.Future.Ptr()
	return Node(p.Struct()), err
}

type Edge capnp.Struct

// Edge_TypeID is the unique identifier for the type Edge.
const Edge_TypeID = 0x86c18ec2991adaea

func NewEdge(s *capnp.Segment) (Edge, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1})
	return Edge(st), err
}

func NewRootEdge(s *capnp.Segment) (Edge, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1})
	return Edge(st), err
}

func ReadRootEdge(msg *capnp.Message) (Edge, error) {
	root, err := msg.Root()
	return Edge(root.Struct()), err
}

func (s Edge) String() string {
	str, _ := text.Marshal(0x86c18ec2991adaea, capnp.Struct(s))
	return str
}

func (s Edge) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Edge) DecodeFromPtr(p capnp.Ptr) Edge {
	return Edge(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Edge) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Edge) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Edge) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Edge) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Edge) Distance() int8 {
	return int8(capnp.Struct(s).Uint8(0))
}

func (s Edge) SetDistance(v int8) {
	capnp.Struct(s).SetUint8(0, uint8(v))
}

func (s Edge) Node() (Node, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return Node(p.Struct()), err
}

func (s Edge) HasNode() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s Edge) SetNode(v Node) error {
	return capnp.Struct(s).SetPtr(0, capnp.Struct(v).ToPtr())
}

// NewNode sets the node field to a newly
// allocated Node struct, preferring placement in s's segment.
func (s Edge) NewNode() (Node, error) {
	ss, err := NewNode(capnp.Struct(s).Segment())
	if err != nil {
		return Node{}, err
	}
	err = capnp.Struct(s).SetPtr(0, capnp.Struct(ss).ToPtr())
	return ss, err
}

// Edge_List is a list of Edge.
type Edge_List = capnp.StructList[Edge]

// NewEdge creates a new list of Edge.
func NewEdge_List(s *capnp.Segment, sz int32) (Edge_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1}, sz)
	return capnp.StructList[Edge](l), err
}

// Edge_Future is a wrapper for a Edge promised by a client call.
type Edge_Future struct{ *capnp.Future }

func (f Edge_Future) Struct() (Edge, error) {
	p, err := f.Future.Ptr()
	return Edge(p.Struct()), err
}
func (p Edge_Future) Node() Node_Future {
	return Node_Future{Future: p.Future.Field(0, nil)}
}

const schema_85f1ec173faff1ee = "x\xdat\xd0\xb1J+A\x18\x05\xe0s\xfe\xd9\xdc\xbd" +
	"\xc5\xbd\xc9.\x09D|\x02\x15\xa3\x04,\xc4FA\xd3" +
	"XH\xa6\xd3B\xc8\x92\x99h nb\x12\xb1\xb1T" +
	";\xed\xf3\x06b\x93\x17\xb0\xd1\xc7\xb0L)\"\xa4\x14" +
	"\x94\x91\x09bD\xb0\x1a8\x9c\xe1;\xfc\xd1\xedFP" +
	"\xfe_\x14\x88\x9e\xc9\xfcqO\x8f\xb3\x83\x87\xeb\xfbK" +
	"\xe8\"\xe9^\xc6\xc3\xf5\xe2\xf3\xf8\x02\x19\x86@<\x1e" +
	"\xc5\xef\xfe}=\x05\xdd\xe6\xdd\xcd\xd5\xf9 y\xfb\xd9" +
	"\x94\x10\xc8\xefq\x94\xb7\xfeO>\xe1\x10%\xd7h\xb6" +
	"l\xa9\xd1\xee\xcaQ\xd2_\xeew\xad]\xaa'\x9d\xb4" +
	"\xb3V\x09\xcd\x81\xad\x92\xfa\xaf\x0a\x80\x80@<\xbf\x0d" +
	"\xe89E\xbd\"$\x0b\xf4Yy\x01\xd0\x8b\x8azU" +
	"\xe8L\xb3\xd7O\xd2\xba\x05@\x81P\xc0\\\xda6\x96" +
	"\xd1t\x13\xc8\x08\xfc\x95\xdd\x09\xdbf\xc2\xfe\xfbb+" +
	"\x9e\xddR\xd4\xb5)\xbb\xef\xd9]Em\x84\xb1\xb0@" +
	"\x01\xe2\xc4\x17k\x8a\xfaL\xe8z\xf6\xf8\xc4~n\xc9" +
	"\x82U\xc5\xc9\xa4,\x98\xebYk\x18@\x18\x80\xae~" +
	"\xd8l\x99\xaeM\xbf\xf5\xa2\xe9\xadA\x1f~\x04\x00\x00" +
	"\xff\xffT\xb0a?"

func RegisterSchema(reg *schemas.Registry) {
	reg.Register(&schemas.Schema{
		String: schema_85f1ec173faff1ee,
		Nodes: []uint64{
			0x86c18ec2991adaea,
			0xfc6199848da8bc43,
		},
		Compressed: true,
	})
}
